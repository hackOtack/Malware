#include <stdlib.h>
#include <iostream>

#ifndef _BASE64_H_
#define _BASE64_H_

#include <vector>
#include <string>
typedef unsigned char BYTE;

std::string base64_encode(BYTE const* buf, unsigned int bufLen);
std::vector<BYTE> base64_decode(std::string const&);

#endif

typedef uint8_t _BYTE;
typedef uint32_t _DWORD;
typedef unsigned char BYTE;


// function declaration
void* malloc_string_decoder(_BYTE* a1, int a2, int* a3);
signed __int64 string_decoder(__int64 a1, __int64 a2, __int64 a3);
void string2ByteArray(char* input, BYTE* output);
void decode(char* input);


int main() {
    char s1[] = "SJ9wllvrxS7p5PxGBC6F5sY9y7za/l1QUE5xms6ztLOP1Yv0pVrU1QNDNnv1DeK9QhqgPNkGQJWNQ99vcDKOyJZA7dEUZ4ePSiSDalyYojj24RU3bQ6/9Og=";
    char s2[] = "SJ9wllvrxS7p5PxGBC6F5sY9y7za/l1QUE5xms6ztLOP1Yv0pVrU1QNDNnv1DeK9QhqgPNkGQJWOfuE9IWfas8FNp4RBM/vmbUmBalz/ghvNsTcPVwCovvF/w7RkxN01Jdl0n4o/LY8nYM646tg+l0EQpsNpcvpQGcNUbF8kIwt9mLxNje+L+EPRGgknKyBLBDW36eJQ0dGZZG5smxfnpvMHhYjQutPiFRA=";
    char s3[] = "SJ9wllvrxS7p5PxGBC6F0sA+37LZ5B9yYVV0s7PflbbZmIWF7grv2TpCO0fvWYPcUQjqN5hCU/6SWMUVaCnC9Y9MqfMfcMPFByrwOQ6+oTu2tBBtNQ6/9O90kqQAl4xvd54V/7oxS6dVCZPwsIZs0x4Mupw=";

    decode(s1);
    decode(s2);
    decode(s3);

    return 0;

}


void decode(char* s1) {

    unsigned int v1 = 0;
    _BYTE input_1[500];
    string2ByteArray(s1, input_1);

    std::vector<BYTE> decodedData = base64_decode(s1);
    //printf("base64decoded size: %d", decodedData.size());
    std::vector<double> v;
    _BYTE* memory = &decodedData[0];
    string_decoder((__int64)memory, (__int64)memory, decodedData.size());
    printf("Original String: \n %s \n ", s1);
    printf("Decoded/decrypted to:\n % .*s\n", (unsigned int)decodedData.size(), memory);

}


void string2ByteArray(char* input, BYTE* output)
{
    int loop;
    int i;

    loop = 0;
    i = 0;

    while (input[loop] != '\0')
    {
        output[i++] = input[loop++];
    }
}

signed __int64 string_decoder(__int64 a1, __int64 a2, __int64 a3)
{
    __int64 v3; // r10
    char v4; // r11
    signed __int64 result; // rax
    unsigned int v6; // er9
    __int64 v7; // rbx
    char v8; // cl

    a3 = (signed int)a3;
    v3 = a2;
    v4 = -124;
    result = 1461817411i64;
    v6 = 162112194;
    if ((signed int)a3 > 0i64)
    {
        v7 = a1 - a2;
        do
        {
            v8 = *(_BYTE*)(v7 + v3++);
            *(_BYTE*)(v3 - 1) = v4 ^ result ^ v6 ^ v8;
            v4 = v4 & result ^ v6 & (v4 ^ result);
            v6 = (v6 >> 8) | ((((unsigned __int16)v6 ^ (unsigned __int16)(8 * v6)) & 0x7F8) << 20);
            result = ((unsigned int)result >> 8) | ((((_DWORD)result << 7) ^ ((unsigned int)result ^ 16
                * ((unsigned int)result ^ 2 * (_DWORD)result)) & 0xFFFFFF80) << 17);
            --a3;
        } while (a3);
    }
    return result;
}

// Base64 encoder/decoder from https://stackoverflow.com/questions/180947/base64-decode-snippet-in-c 
static const std::string base64_chars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"0123456789+/";


static inline bool is_base64(BYTE c) {
    return (isalnum(c) || (c == '+') || (c == '/'));
}

std::string base64_encode(BYTE const* buf, unsigned int bufLen) {
    std::string ret;
    int i = 0;
    int j = 0;
    BYTE char_array_3[3];
    BYTE char_array_4[4];

    while (bufLen--) {
        char_array_3[i++] = *(buf++);
        if (i == 3) {
            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
            char_array_4[3] = char_array_3[2] & 0x3f;

            for (i = 0; (i < 4); i++)
                ret += base64_chars[char_array_4[i]];
            i = 0;
        }
    }

    if (i)
    {
        for (j = i; j < 3; j++)
            char_array_3[j] = '\0';

        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
        char_array_4[3] = char_array_3[2] & 0x3f;

        for (j = 0; (j < i + 1); j++)
            ret += base64_chars[char_array_4[j]];

        while ((i++ < 3))
            ret += '=';
    }

    return ret;
}

std::vector<BYTE> base64_decode(std::string const& encoded_string) {
    int in_len = encoded_string.size();
    int i = 0;
    int j = 0;
    int in_ = 0;
    BYTE char_array_4[4], char_array_3[3];
    std::vector<BYTE> ret;

    while (in_len-- && (encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
        char_array_4[i++] = encoded_string[in_]; in_++;
        if (i == 4) {
            for (i = 0; i < 4; i++)
                char_array_4[i] = base64_chars.find(char_array_4[i]);

            char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

            for (i = 0; (i < 3); i++)
                ret.push_back(char_array_3[i]);
            i = 0;
        }
    }

    if (i) {
        for (j = i; j < 4; j++)
            char_array_4[j] = 0;

        for (j = 0; j < 4; j++)
            char_array_4[j] = base64_chars.find(char_array_4[j]);

        char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
        char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

        for (j = 0; (j < i - 1); j++) ret.push_back(char_array_3[j]);
    }

    return ret;
}