
#include <Windows.h>
#include <iostream>
#include <iostream>
#include <cstring>
#include <cstdint>
#include <cstddef>
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>

#include <peconv.h> // include libPeConv header
using namespace std;


typedef unsigned char BYTE;
typedef struct _MY_UNICODESTR {
	wchar_t* Buffer;
	DWORD padding;
	uint64_t Length;
	uint64_t MaxLength;
} MY_UNICODESTR;


size_t g_PESize = 0;
BYTE* g_myPE = NULL;

int load_and_run(LPCSTR pe_path)
{
	g_myPE = peconv::load_pe_executable(pe_path, g_PESize);
	if (!g_myPE) {
		return -1;
	}
	__int64 (__fastcall* dllmain_dispatch)(HINSTANCE hinstDLL, DWORD fdwReason, void* const lpvReserved) = (__int64(__fastcall*)(HINSTANCE , DWORD, void* const))(0x29814 + (ULONG_PTR)g_myPE);
	dllmain_dispatch((HINSTANCE)g_myPE, DLL_PROCESS_ATTACH, 0);
	return 1;
}



MY_UNICODESTR* (__fastcall* string_prep)(MY_UNICODESTR* out_ustr, const wchar_t* in_wstr, unsigned __int64 size) = (MY_UNICODESTR* (*)(MY_UNICODESTR*, const wchar_t*, unsigned __int64))((ULONG_PTR)g_myPE + 0x081A0);
__int64(__fastcall* string_decryptor)(MY_UNICODESTR* a1, MY_UNICODESTR* out_buf) = (__int64(__fastcall*)(MY_UNICODESTR*, MY_UNICODESTR*))((ULONG_PTR)g_myPE + 0x1B330);
void parse_labels();
vector<string> split(const string& str, const string& delim);
void dump_str(MY_UNICODESTR* outs);

int main(int argc, char* argv[])
{
	const LPCSTR pe_path = "C:\\Users\\REM\\Desktop\\malware.dll"; // sample used ae50cf4339ff2f2b3a50cf8e8027b818b18a0582e143e842bf41fdb00e0bfba5
	int res = load_and_run(pe_path);
	std::cout << "Loaded file result: " << res << "\n base address: \n" << (ULONG_PTR)g_myPE << "\n";
	
	string_prep = (MY_UNICODESTR * (*)(MY_UNICODESTR*, const wchar_t*, unsigned __int64))((ULONG_PTR)g_myPE + 0x081A0);
	string_decryptor= (__int64(__fastcall*)(MY_UNICODESTR*, MY_UNICODESTR*))((ULONG_PTR)g_myPE + 0x1B330);


	/*example of decrypting a string*/
	MY_UNICODESTR buffer = { 0 };
	MY_UNICODESTR out_buf = { 0 };
	string_prep(&buffer, L"370d6e253a3a93578a1081bc37558c01722c167025728cb4506e8b5b00", 0x3A);
	string_decryptor(&buffer, &out_buf);
	dump_str(&out_buf);


	/*decode encrypted strings in a file:*/
	//parse_labels();
	
	return 0; 
}


void parse_labels() {
	std::ifstream input("C:\\Users\\REM\\Desktop\\String_xref_values.txt");

	for (std::string line; getline(input, line); )
	{
		vector<string> tokens = split(line, ",");
		
		string encrypted_s = tokens[2];
		MY_UNICODESTR buffer = { 0 };
		MY_UNICODESTR out_buf = { 0 };
		
		std::wstring wstr1 = std::wstring(encrypted_s.begin(), encrypted_s.end());
		string_prep(&buffer, wstr1.c_str(), encrypted_s.length());
		string_decryptor(&buffer, &out_buf);

		if (out_buf.Length != 0) {
			std::cout << tokens[0] << "\n";
			dump_str(&out_buf); 
		}
		else {
			std::cout << "\n" << tokens[0] << "Empty RESULT!";
		}

	}
}



void dump_str(MY_UNICODESTR* outs)
{
	std::wcout << "decoded_string: \n" << outs->Buffer << "\n";
}

vector<string> split(const string& str, const string& delim)
{
	vector<string> tokens;
	size_t prev = 0, pos = 0;
	do
	{
		pos = str.find(delim, prev);
		if (pos == string::npos) pos = str.length();
		string token = str.substr(prev, pos - prev);
		if (!token.empty()) tokens.push_back(token);
		prev = pos + delim.length();
	}     while (pos < str.length() && prev < str.length());
	return tokens;
}

