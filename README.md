- git clone https://github.com/hasherezade/libpeconv.git or use https://github.com/hackOtack/Malware/tree/master
- CMake GUI 
- Configure and generate the project template https://github.com/hasherezade/libpeconv/wiki/Building-the-library 


# Examples: 

## load PE:

```
bool load_payload(LPCTSTR pe_path)
{
	if (g_Payload) {
		// already loaded
		std::cerr << "[!] The payload is already loaded!!\n";
		return false;
	}
#ifdef LOAD_FROM_PATH
	//if the PE is dropped on the disk, you can load it from the file:
	g_Payload = peconv::load_pe_executable(pe_path, g_PayloadSize);
#else // load from memory buffer
	/*
	in this example the memory buffer is first loaded from the disk,
	but it can as well be fetch from resources, or a hardcoded buffer
	*/
	size_t bufsize = 0;
	BYTE* buf = peconv::load_file(pe_path, bufsize);
	if (!buf) {
		return false;
	}
	// if the file is NOT dropped on the disk, you can load it directly from a memory buffer:
	g_Payload = peconv::load_pe_executable(buf, bufsize, g_PayloadSize);

	// at this point we can free the buffer with the raw payload:
	peconv::free_file(buf); buf = nullptr;
	
#endif
	if (!g_Payload) {
		return false;
	}

	// if the loaded PE needs to access resources, you may need to connect it to the PEB:
	peconv::set_main_module_in_peb((HMODULE)g_Payload);

	// load delayed imports (if present):
	const ULONGLONG loadBase = (ULONGLONG)g_Payload;
	peconv::load_delayed_imports(g_Payload, loadBase);

	return true;
}

if (!load_payload(pe_path)) {
	return -1;
}
```


                           

## Run EXE:

1.  run PE main function 


```int run_payload(DWORD ep_rva, std::string function_definition)
{

	// if needed, you can run TLS callbacks before the Entry Point:
	peconv::run_tls_callbacks(g_Payload, g_PayloadSize);
	std::cerr << "TLS callbacks were executed!\n";

	//calculate the Entry Point of the manually loaded module
  // ep_rva can be replaced with an offset to another function 
  ep_rva = peconv::get_entry_point_rva(g_Payload);
  if (!ep_rva) {
    std::cerr << "[!] Cannot fetch EP!\n";
    return -2;
  }

	const ULONG_PTR ep_va = ep_rva + (ULONG_PTR)g_Payload;
 
  int basic_main(void);
  auto new_main = reinterpret_cast<decltype(&basic_main)>(ep_va);
  //call the Entry Point of the manually loaded PE:
  ret = new_main();
	return ret;
}
```

## Run DLL:

1.  load a DLL and run dll main: 

  ```
if (peconv::is_module_dll(g_Payload)) {
	//the prototype of the DllMain fuction:
	BOOL WINAPI _DllMain(
		HINSTANCE hinstDLL,  // handle to DLL module
		DWORD fdwReason,     // reason for calling function
		LPVOID lpvReserved);  // reserved
 auto new_main = reinterpret_cast<decltype(&_DllMain)>(ep_va);
	// call the Entry Point of the manually loaded PE :
	ret = new_main((HINSTANCE)g_Payload, DLL_PROCESS_ATTACH, 0);
}

```

2.  load a dll and run an export function by ordinal: 

```

    HMODULE hLib = LoadLibraryA(dll_path);
    if (hLib == NULL) {
        return -1;
    }
    exported_func = (DWORD (*) (DWORD, DWORD, LPSTR, DWORD)) 
        GetProcAddress(hLib, MAKEINTRESOURCE(1));
    
    if (exported_func == NULL) {
        return -1;
    }
    exported_func(0, 0, checked_str, 0);
```
